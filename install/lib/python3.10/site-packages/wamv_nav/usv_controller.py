#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
"""
USV Controller
· /Boat_i/action → thrusters
· subscribe Gazebo odometry and republish on
  /wamv/sensors/position/ground_truth_odometry
· publish /Boat_i/state (UxVState)
"""

import math, collections, time, sys, os, signal
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Vector3, Quaternion
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64
from px4_uv.msg import Action, UvState

REF_LAT, REF_LON = 35.227108, 126.840301
R_EARTH          = 6378137.0

def yaw_from_q(q: Quaternion):
    s = 2*(q.w*q.z + q.x*q.y)
    c = 1-2*(q.y*q.y + q.z*q.z)
    return math.atan2(s, c)

class SingleUSV:
    def __init__(self, node: Node, idx: int):
        self.n    = node
        self.idx  = idx
        boat    = f'/Boat_{idx}'
        model   = f'/model/wamv_{idx}/odometry'
        # thruster pubs
        self.pubL = node.create_publisher(Float64, f'/wamv_{idx}/thrusters/left/thrust', 10)
        self.pubR = node.create_publisher(Float64, f'/wamv_{idx}/thrusters/right/thrust',10)
        # odom republisher
        self.pubO = node.create_publisher(Odometry,
                                          '/wamv/sensors/position/ground_truth_odometry', 10)
        # state pub
        self.pubS = node.create_publisher(UvState, f'{boat}/state', 10)
        # subs
        node.create_subscription(Action, f'{boat}/action', self.cb_action, 10)
        node.create_subscription(Odometry, model, self.cb_odom, 10)
        node.create_timer(0.1, self.pub_state)

        self.wps = collections.deque()
        self.mode = 'IDLE'
        self.status = UvState.VEHICLE_STATUS_STOP
        self.pos = Vector3(); self.vel = Vector3(); self.yaw = 0.0
        self.int_d = self.int_y = 0.0
        self.t0 = None

        node.get_logger().info(f'Boat_{idx} controller ready')

    def cb_action(self, m: Action):
        self.wps.clear(); self.int_d = self.int_y = 0.0
        self.hover = m.param1
        a = m.action
        if a == m.ACTION_MOVE:
            self._push(m.setpoint.x, m.setpoint.y)
            self.mode = 'MOVE'; self.status = UvState.VEHICLE_STATUS_NORMAL
        elif a == m.ACTION_RETURN_HOME:
            self._push(REF_LAT, REF_LON)
            self.mode = 'MOVE'; self.status = UvState.VEHICLE_STATUS_NORMAL
        elif a == m.ACTION_PATROL:
            self._push(m.setpoint.x, m.setpoint.y)
            self._push(m.param2, m.param3)
            self.mode = 'PATROL'; self.status = UvState.VEHICLE_STATUS_NORMAL
        elif a == m.ACTION_LANDING:
            self._push(m.setpoint.x, m.setpoint.y)
            self.mode = 'MOVE'; self.status = UvState.VEHICLE_STATUS_NORMAL
        else:
            self.mode = 'IDLE'; self.status = UvState.VEHICLE_STATUS_STOP

    def cb_odom(self, od: Odometry):
        # republish ground-truth odom
        self.pubO.publish(od)
        # process for control...
        # [SNIP: same as before, update self.pos, self.vel, self.yaw]
        # compute thruster commands, etc.

    def pub_state(self):
        s = UvState()
        s.pos = self.pos
        s.vel = self.vel
        s.current_yaw = float(self.yaw)
        s.ref_lat = REF_LAT
        s.ref_lon = REF_LON
        s.ref_alt = 0.0
        s.battery = 100
        s.status = self.status
        self.pubS.publish(s)

    def _push(self, la, lo):
        # convert lat/lon to ENU
        dlat = math.radians(la - REF_LAT)
        dlon = math.radians(lo - REF_LON)
        x = dlon * R_EARTH * math.cos(math.radians(REF_LAT))
        y = dlat * R_EARTH
        self.wps.append((x,y))

def main(args=None):
    rclpy.init(args=args)
    node = Node('usv_controller')
    num = node.declare_parameter('num_robots',1).value
    ctrl = [SingleUSV(node, i+1) for i in range(num)]
    try:
        rclpy.spin(node)
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__=='__main__':
    main(sys.argv)

